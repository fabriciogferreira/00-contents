Estrutura léxica:
    Conunto de caracteres: Unicode
        Case sensitive: Sim
        Espaços em branco: Ignorados
            " " == tabulação (\u0009), tabulação vertical (\u000B), avanço de página (\u000C), espaço não separável (\u00A0), marca de ordem de byte (\uFEFF) e qualquer caractere unicode da categoria Zs.
        Quebra de linhas: Ignorados
            ";" == avanço de linha (\u000A), retorno de carro (\u000D), separador de linha (\u2028) e separador de parágrafo (\u2029).
        Escapes Unicode:
            Alguns Hardwares e softwares não conseguem exibir ou introduzir o conjunto completo de caracteres Unicode. O JS define sequências especiais de seis caracteres ASCII para representar qualquer código Unicode de 16 bits. 
            Estrutura: \u...
                ... == hexadecimal
                ... == Números, A-F e a-f
            Permitido em:
                Strings literais: Sim
                Expressões regulares literais: Sim
                Identificadores: Sim
                Palavras-chaves: Não
                Comentários: Sim, mas como os comentários são ignorados, eles são tratados como caracteres ASCII nesse contexto e não são interpretados como Unicode.
                Exemplo:
                    "café" === "caf\u00e9" // => true
        Normalização:
            Use escapes unicodes somente quando o hardware e/ou software não suporta o caracter "normal". JavaScript presume que o código-fonte que está interpretando já foi normalizado e não tenta normalizar identificadores, strings nem expressões regulares.
    Comentários:
        //: entre '//' e o final da linha é comentário
        /**/: entre '/*' e '*/' é comentário
    Literais:
        É um valor de dados que aparece diretamente em um programa.
            12              - O número doze
            1.2             - O número um ponto dois
            "hello world"   - Uma string de texto
            'Hi'            - Outra string
            true            - Um valor booleano
            false           - O outro valor booleano
            /javascript/gi  - Uma "expressão regular" literal (para comparação de padrões)
            null            - Ausência de um objeto
    Identificadores:
        Um identificador é simplesmente um nome que são usados para dar nomes a variáveis e funções e para fornecer rótulos para certos laços no código JavaScript. 
        Estrtura:
            Letra...
            _...
            $...
            ... = Letras, digitos, sublinhados e/ou cifrões
        Conevenção:
            letras e digitos
        Palavras reservadas:
            JavaScript reserva vários identificadores como palavras-chave da própria linguagem. Você não pode usar essas palavras como identificadores em seus programas:
                Colocar as palvras reservadas aqui
                Considerar as propriedades do objeto global como palavra reservada
    Pontos e virgulas:
        Você pode usar para marcar explicitamente, mas não é obrigatório, exceto em algumas exceções.
            Final de programa = Não necessário
            Próximo sinal '}' = Não necessário
            Linhas separadas = Não necessário
        Você pode omitir, mas ter que utilizar quando necessário
        Minha opinião: Parece ter muito mais vantagens utilizar ';'

Tipos, valores e váriaveis:
    Tipos:
        Imutaveis e mutaveis
        Com métodos e sem métodos
        Primitivos:
            Number
            Sting
            Boolean
            Null
            Undefined
        Objeto: é um conjunto de propriedades, em que cada propriedade tem um nome e um valor (ou um valor primitivo, como um número ou string, ou um objeto).
            Array
            Function
            Date
            RegExp
            Error
    Números:
        Ponto flutuante:
            Max: ±1,7976931348623157 × 10^308
            Min: ±5 × 10^−324.
            Notação: Reconheçe
                Estrutura: 1.3232131(E ou e)(- ou +)32
        Inteiros: 
            Max: −9007199254740992 (−2^53) 
            Min: 9007199254740992 (2^53),
            Exeções: Note, entretanto, que certas operações em JavaScript (como indexação de arrays e os operadores bit a bit descritos no Capítulo 4) são efetuadas com inteiros de 32 bits.
            Hexadecimal: Reconheçe
                Estrutura:
                    0x...
                    0X...
            Octal: Reconheçe, mas é altamente não recomendado utilizar
                Estrutura:
                    0...

Operadores aritméticos:
    + - Adição
    – - Subtração
    * - Multiplicação
    / - Divisão 
    % - Módulo (resto da divisão).
    Erros:
        Não gera erros em casos de estouro, estouro negativo ou divisão por zero.
        Estouro: Quando o resultado de uma operação numérica é maior do que o maior número representável (estouro).
            Resultado > limite          - Retorna Infinity
            Resultado < limite negativo - Retorna -Infinity
                Para saber se é finito, use isFinite() retorna Verdadeiro, o argumento for um número diferente de NaN, Infinity ou -Infinity
            Exceção:
                0/0 - Retorna NaN (not-a-number)
                (-)infinity/(-)infinity - Retorna NaN
                sqrt(-N) - Retorna NaN
                3*"f3" - Retorna NaN operadores aritméticos com operandos não numéricos que não podem ser convertidos em números.
                Para saber se é NaN compara x != x, vai retorna verdadeiro caso seja, ou use isNaN, retorna verdadeiro caso seja NaN ou seja um valor não numérico
        Estouro Negativo: O estouro negativo ocorre quando o resultado de uma operação numérica é mais próximo de zero do que o menor número representável.
            Retorna -0 ou 0
                var zero = 0;       - Zero normal
                var negz = -0;      - Zero negativo
                zero === negz       - => verdadeiro: zero e zero negativo são iguais
                1/zero === 1/negz   - => falso: infinito e -infinito não são iguais


Datas e horas
    var then = new Date(2010, 0, 1);// O 1o dia do 1o mês de 2010
    var later = new Date(2010, 0, 1,// O mesmo dia, às 5:10:30 da tarde, hora local 17, 10, 30);
    var now = new Date();       - A data e hora atuais
    var elapsed = now – then;   - Subtração de data: intervalo em milissegundos
    later.getFullYear()         - => 2010
    later.getMonth()            - => 0: meses com base em zero
    later.getDate()             - => 1: dias com base em um
    later.getDay()              - => 5: dia da semana. 0 é domingo, 5 é sexta-feira.
    later.getHours()            - => 17: 5 da tarde, hora local
    later.getUTCHours()         - Horas em UTC; depende do fuso horário
    later.toString()            - => "Sexta-feira, 01 de janeiro de 2010, 17:10:30 GMT-0800 (PST)"
    later.toUTCString()         - => "Sábado, 02 de janeiro de 2010, 01:10:30 GMT"
    later.toLocaleDateString()  - => "01/01/2010"
    later.toLocaleTimeString()  - => "05:10:30 PM"
    later.toISOString()         - => "2010-01-02T01:10:30.000Z"; somente ES5

Bibliotecas:
    Math:
        Math.pow(2,53)          - => 9007199254740992: 2 elevado à potência 53
        Math.round(.6)          - => 1.0: arredonda para o inteiro mais próximo
        Math.ceil(.6)           - => 1.0: arredonda para cima para um inteiro
        Math.floor(.6)          - => 0.0: arredonda para baixo para um inteiro
        Math.abs(-5)            - => 5: valor absoluto
        Math.max(x,y,z)         - Retorna o maior argumento
        Math.min(x,y,z)         - Retorna o menor argumento
        Math.random()           - Número pseudoaleatório x, onde 0 <= x < 1.0
        Math.PI                 - π: circunferência de um círculo / diâmetro
        Math.E                  - e: A base do logaritmo natural
        Math.sqrt(3)            - A raiz quadrada de 3
        Math.pow(3, 1/3)        - A raiz cúbica de 3
        Math.sin(0)             - Trigonometria: também Math.cos, Math.atan, etc.
        Math.log(10)            - Logaritmo natural de 10
        Math.log(100)/Math.LN10 - Logaritmo de base 10 de 100
        Math.log(512)/Math.LN2  - Logaritmo de base 2 de 512
        Math.exp(3)             - Math.E ao cubo
Sites:
    JavaScript progressivo
    dojo puzzles

Texto
    Uma string é uma sequência ordenada imutável de valores de 16 bits,
    Strings listerais
        Declaração: O conteúdo deve ficar entre aspas simples ou aspas duplas, elas podem se conter
        Várias linhas em uma linha: Use o \n para definir uma quebra de linha
        Várias linhas: Basta termianar cada linha com '\'
    Escapes:
        \n  - nova linha (\u000A)
        \'  - caracter de apóstrofe ou aspas simples dentro de strins literais que são delimitadas por aspas simples (\u0027)
        \0  - O caractere NUL (\u0000)
        \b  - Retrocesso (\u0008)
        \t  - Tabulação horizontal (\u0009)
        \v  - Tabulação vertical (\u000B)
        \f  - Avanço de página (\u000C)
        \r  - Retorno de carro (\u000D)
        \"  - Aspas duplas (\u0022)
        \\  - Barra invertida (\u005C)
        \x  - XX O caractere Latin-1 especificado pelos dois dígitos hexadecimais XX
        \u  - XXXX O caractere Unicode especificado pelos quatro dígitos hexadecimais XXXX
    Concatenar
        Para basta colocar um '+' entre strings literais e/ou variaveis
    Propriedades
        var s = "hello, world"  - => Começa com um texto.
        s.charAt(0)             - => "h": o primeiro caractere.
        s.charAt(s.length-1)    - => "d": o último caractere.
        s.substring(1,4)        - => "ell": o 2o, 3o e 4o caracteres.
        s.slice(1,4)            - => "ell": a mesma coisa
        s.slice(-3)             - => "rld": os últimos 3 caracteres
        s.indexOf("l")          - => 2: posição da primeira letra l.
        s.lastIndexOf("l")      - => 10: posição da última letra l.
        s.indexOf("l", 3)       - => 3: posição do primeiro "l" em ou após 3
        s.split(", ")           - => ["hello", "world"] divide em substrings
        s.replace("h", "H")     - => "Hello, world": substitui todas as instâncias
        s.toUpperCase()         - => "HELLO, WORLD"
        Lembre-se de que as strings são imutáveis em JavaScript. Métodos como replace() e toUpperCase() retornam novas strings
        Obs: caso os conteúdos das strings literais e/ou váriaveis sejam números, ele irá somar

Booleano
    Sim ou não, ligado ou desligado, verdadeiro ou falso, true ou false.
    Verdadeiro
        É 'true'
        Valores convertidos:
            Qualquer outro valor diferente dos valores de false
    Falso
        É 'false'
        Valores convertidos:
            undefined
            null
            0
            -0
            NaN
            "" // a string vazia
Null
    null é uma palavra-chave da linguagem avaliada com um valor especial, normalmente utilizado para indicar a ausência de um valor.
    Para comparar null, use o '=='
    Null não possui propriedades ou métodos
Undefined
    O valor indefinido representa uma ausência de valor mais profunda. 
    Para comparar undefined, use o '==='
    Undefined não possui propriedades ou métodos
    Existe quando:
        Variáveis que não foram inicializadas.
        Quando se consulta o valor de uma propriedade de objeto ou elemento de array que não existe.
        Funções que não têm valor de retorno
        Valor de parâmetros de função quando os quais nenhum argumento é fornecido.
O objeto global
    Quando o interpretador JavaScript começa (ou quando um navegador Web carrega uma nova página), ele cria um novo objeto global e dá a ele um conjunto inicial de propriedades que define:
        propriedades globais, como undefined, Infinity e NaN
        funções globais, como isNaN(), parseInt() e eval().
        funções construtoras, como Date(), RegExp(), String(), Object() e Array()
        objetos globais, como Math e JSON
    No código de nível superior – código JavaScript que não faz parte de uma função –, pode-se usar a palavra-chave this de JavaScript para se referir ao objeto global:
        var global = this;  - Define uma variável global para se referir ao objeto global
    o objeto Window serve como objeto global para todo código JavaScript contido na janela do navegador que ele representa. Esse objeto global Window tem uma propriedade de autoreferência window que pode ser usada no lugar de this para se referir ao objeto global.

Objetos wrapper (pg 41 a 43)
    Os objetos JavaScript são valores compostos: eles são um conjunto de propriedades ou valores nomeados.
    Ao usarmos a notação . fazemos referência ao valor de uma propriedade.
    Quando o valor de uma propriedade é uma função, a chamamos de método.
    Strings não objetos apesar de "ter" propriedades e métodos, quando você refere uma propriedade da string, ele converte o valor da string em um objeto que herda métodos da string e é utilizado para solucionar a referência da propriedade. Uma vez solucionada a propriedade, o objeto recentemente criado é descartado. (As implementações não são obrigadas a criar e descartar esse objeto transitório – contudo, devem se comportar como se fossem.). Isso também vale para números e booleanos
    Os objetos temporários criados ao se acessar uma propriedade de uma string, número ou valor booleano são conhecidos como objetos empacotadores (wrapper) e ocasionalmente pode ser necessário diferenciar um valor de string de um objeto String ou um número ou valor booleano de um objeto Number ou Boolean.
    Basta saber que string, número e valores booleanos diferem de objetos pois suas propriedades são somente para leitura e que não é possível definir novas propriedades neles.
    Criar objetos wrapper:
        var s = "test", n = 1, b = true;    - Uma string, um número e um valor booleano.
        var S = new String(s);              - Um objeto String
        var N = new Number(n);              - Um objeto Number
        var B = new Boolean(b);             - Um objeto Boolean

Valores primitivos imutáveis e referências de objeto mutáveis
    valores primitivos (undefined, null, booleanos, números e strings) são imutáveis
    objetos/tipos de referência (incluindo arrays e funções) são mutáveis
    Objetos não são comparados por valor:
        var o = {x:1}, p = {x:1};   - Dois objetos com as mesmas propriedades
        o === p                     - => falso: objetos distintos nunca são iguais
        var a = [], b = [];         - Dois arrays vazios diferentes
        a === b                     - => falso: arrays diferentes nunca são iguais
    Usando essa terminologia, os valores de objeto são referências e dizemos que os objetos são comparados por referência: dois valores de objeto são iguais se, e somente se, eles se referem ao mesmo objeto básico.
        var a = []; - A variável a se refere a um array vazio.
        var b = a;  - Agora b se refere ao mesmo array.
        b[0] = 1;   - Muda o array referido pela variável b.
        a[0]        - => 1: a mudança também é visível por meio da variável a.
        a === b     - => verdadeiro: a e b se referem ao mesmo objeto; portanto, são iguais.
    Nova cópia de um objeto ou array:
        var a = ['a','b','c']; // Um array que queremos copiar
        var b = []; // Um array diferente no qual vamos copiar
        for(var i = 0; i < a.length; i++) { // Para cada índice de []
            b[i] = a[i]; // Copia um elemento de a em b
        }
    Para comparar arrays ou objetos, devemos comparar seus elementos e propriedades:
        function equalArrays(a,b) {
            if (a.length != b.length) return false; - Arrays de tamanho diferente não são iguais
            for(var i = 0; i < a.length; i++)       - Itera por todos os elementos
                if (a[i] !== b[i]) return false;    - Se algum difere, os arrays não são iguais
            return true;                            - Caso contrário, eles são iguais
        }

Conversões (pg 45)
Conversões e igualdade
Conversões Explícitas (46)
    Number("3")     - => 3
    String(false)   - => "false" Ou use false.toString()
    Boolean([])     - => verdadeiro
    Object(3)       - => novo Number(3)
Conversões de objeto para valores primitivos

"7" * "4" = 28

não há como alterar (ou “mudar”) um valor primitivo.
React
    Gerador de piadas
    Jogo da velha
    Validação de formato
    Pokedex
    previsão do tempo
        




------------/Termos\------------
Expressão: Uma expressão é uma frase em JavaScript que pode ser avaliada para produzir um valor. O uso de . e [] para se referir ao valor de uma propriedade de objeto ou a um elemento de array é uma expressão, por exem

------------/Sintax\------------
Comando devem terminar em ';'

------------/Variaveis\------------
var x; - Declarração da váriavel x
 
------------/Atribuição\------------
Utiliza-se '=' entre o que vai ser atribuído e quem está recebendo a atribuição
x = 0; Atribui o valor (número) para a váriavel x

------------/Operadores Aritméticos\-------------
3 + 2       - Mostra 5, se trata da adição
3 - 2       - Mostra 1, se trata de subtração
3 * 2       - Mostra 6, se trata de multiplicação
3 / 2       - Mostra 1.5 se trata de divisão
"3" + "2"   - Mostra 32 
points[1].x – points[0].x // => 1: operandos mais complicados também funcionam?

Abreviados:
var count = 0;  // Define uma variável
count++;        // Incrementa de 1 em 1 na variável
count--;        // Decrementa de 1 em 1 na variável
count += 2;     // Soma 2: o mesmo que count = count + 2;
count *= 3;     // Multiplica por 3: o mesmo que count = count * 3;
count           // => 6: nomes de variáveis também são expressões.

------------/Operadores Relacionais\-------------
var x = 2, y = 3; 
x == y              - mostra falso: igualdade
x != y              - mostra verdadeiro: desigualdade
x < y               - mostra verdadeiro: menor que
x <= y              - mostra verdadeiro: menor ou igual a
x > y               - mostra falso: maior que
x >= y              - mostra falso: maior ou igual a
"two" == "three"    - mostra falso: as duas strings são diferentes
"two" > "three"     - mostra verdadeiro: "tw" é alfabeticamente maior do que "th"
false == (x > y)    - mostra verdadeiro: falso é igual a falso

------------/Operadores Lógicos\-------------
A condições que eles vão associar, precisam estar entre parenteses

Operador E/And/&&:
(x == 2) && (y == 3) - verdadeiro: as duas comparações são verdadeiras

Operador Ou/Or/||:
(x > 3) || (y < 3)   - falso: nenhuma das comparações é verdadeira. || é OU

Operador Não/Not/!:
!(x == y)            - verdadeiro: ! inverte um valor booleano

------------/Tipos\------------
numeroInteiro = 1;      - Apenas números do conjunto dos inteiros
numeroReias = 3.14;     - Apenas números do conjunto dos reais, só possível armazenar os números deles, então não tem como armazenar o símbolo 'pi" 
string = "Hello World"; - Sequencia de caracteres (texto) que formas uma string
string = 'Hello World'; - Igual ao de cima
boolean = true;         - O tipo boolean, verdadeiro ou falsox 
boolean = false;        - O tipo boolean, verdadeiro ou falsox 
x = null;               - É váriavel que representa nada/nulo/nenhum valor, não confunda com 0, 0 e nulo são diferentes
x = undefined;          - ?
/Object                 - Um conjunto pares de nome e valor\
Var book = {
    topic: "JavaScript",
    fat: true
}

------------/Estrutura condicional\------------
Obs: Chaves são opcionais quando há 1 instrução por cláusula.
if (x >= 0) {   // 'if' (significa 'se') inicia a estrutura condicional, '()' onde fica as condições, '{' abre a primeira cláusula
   return x;    // Se a comparação for verdadeira, retorna 'x'.
} else {        // '}' fecha a primeira cláusula, 'else' (significa 'senão') se a condição for falsa, executa a segunda claúsula, '{' abre a segunda claúsula  
return -x;      // Se a comparação for falsa, retorna '-x'. 
}               // '}' fecha a segunda claúsula
Funciona da seguinte forma: se (if) isso for verdadeiro (()), faça isso ({}), senão (else), faça isso ({})

------------/Estruturas de repetição\------------
While:
while(n > 1) {      - 'while' (significa 'enquanto') inicia a estrutura repetitiva, '()' onde fica as condições, '{' abre a primeira cláusula
    product *= n;   - Atalho para product = product * n;
    n--;            - Atalho para n = n – 1
}                   - '}' fecha a estrutura repetitiva
Funciona da seguinte forma: enquanto (while) isso for verdadeiro (()), faça isso ({})

for:
for(i=2; i <= n; i++){  - 'for' (significa 'durante'), '(variaveis; condição; incremento)' regras da estrutura, '{' abre a cláusula
   product *= i;        - Faz isso a cada vez. {} não é necessário para laços
}                       - '}' fecha a estrutura repetitiva


------------/Funções\------------
function plus1(x) { - não é preciso passar o tipo da váriavel
return x+1;         - Retorna um valor uma unidade maior do que o que foi passado
}
plus1(y)            - Chama a função 'plus1(y)', ela retorna o valor passado mais 1
var square = function(x) { - As funções são valores e podem ser atribuídas a variáveis
 return x*x;               - Calcula o valor da função
};                         - Um ponto e vírgula marca o fim da atribuição
quare(plus(y))             - 16: chama duas funções em uma única expressão

------------/Métodos\------------
// Quando funções recebem as propriedades de um objeto, as chamamos de "métodos". Todos os objetos de JavaScript têm métodos:
var a = [];     - Cria um array vazio
a.push(1,2,3);  - O método push() adiciona elementos em um array
a.reverse();    - Outro método: inverte a ordem dos elementos

// Também podemos definir nossos próprios métodos. A palavra-chave "this" se refere ao objeto no qual o método é definido: neste caso, o array de pontos anterior.
points.dist = function() { // Define um método para calcular a distância entre
 // pontos
 var p1 = this[0];              // Primeiro elemento do array que chamamos
 var p2 = this[1];              // Segundo elemento do objeto "this"
 var a = p2.x-p1.x;             // Diferença em coordenadas X
 var b = p2.y-p1.y;             // Diferença em coordenadas Y
 return Math.sqrt(a*a + b*b);   // O teorema de Pitágoras               
                                // Math.sqrt() calcula a raiz quadrada
};
points.dist() // => 1,414: distância entre nossos 2 pontos

------------/Arrays\------------
Uma lista indexada numericamente onde cada posição pode possui um valor
var primos = [2, 3, 5, 7];
primos[0];                  - Acessa e mostra 2
primos.lenght;              - Mostra o tamanho do array
primos[primos.lenght-1];    - Mostra a posição 3 do array, o valor 7 
primos[4] = 9;              - Atribui o valor 9 a posição 4 do array 'primos'
primos[4] = 11;             - Atribui o valor  11 a posição 4 do array 'primos'

É possível criar arrays que contém Objetos
var points [        - Um array com dois elementos
    {x:0, y:0},     - Primeiro elemento
    {x:1, y:1}      - Segundo elemento
];

------------/Objetos\------------
Acessando valores das propriedades:
book.topic                  - Acessa o valor da propriedades topic, mostra "JavaScript"
book.["fat"]                - Outro mode de acessar valores, mostra "true"
book.author = "Flanagan";   - Cria uma nova propriedade caso não exista, se existir, atribui um valor a váriavel
book.contents = {};         - Cria uma nova propriedade caso não exista, se existir, atribui um valor nulo

O contrario também, é possível criar objetos que contém array
var data ={                     - Um objeto com duas propriedades
    trial1: [[1, 2], [3, 4]],   - Primeira propriedade
    trial2: [[2, 3], [4, 5]],   - Segunda propriedade
};



Entidade                
    Algo de interesse da comunidade de usuários de banco de dados. Os exemplos incluem clientes, peças, localizações geográficas, etc.
Coluna                  
    Uma parte individual dos dados armazenados em uma tabela.
Linha                   
    Um conjunto de colunas que juntas descrevem completamente uma entidade ou alguma ação em uma entidade. Também chamado de registro.
Tabela                  
    Um conjunto de linhas, mantido na memória (não persistente) ou no armazenamento permanente (persistente).
Conjunto de resultados  
    Outro nome para uma tabela não persistente, geralmente o resultado de uma consulta SQL.
Chave primária          
    Uma ou mais colunas que podem ser usadas como um identificador exclusivo para cada linha em uma tabela.
Chave estrangeira       
    Uma ou mais colunas que podem ser usadas juntas para identificar uma única linha em outra tabela